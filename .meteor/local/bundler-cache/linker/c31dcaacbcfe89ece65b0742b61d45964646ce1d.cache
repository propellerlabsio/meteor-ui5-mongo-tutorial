[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"shell-server\":{\"main.js\":[\"./shell-server.js\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/shell-server/main.js                                                                                //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\nmodule.import(\"./shell-server.js\",{'*':function(v,k){exports[k]=v;}});var listen;module.import(\"./shell-server.js\",{\"listen\":function(v){listen=v}});\n                                                                                                                // 2\n                                                                                                                //\nvar shellDir = process.env.METEOR_SHELL_DIR;                                                                    // 4\nif (shellDir) {                                                                                                 // 5\n  listen(shellDir);                                                                                             // 6\n}                                                                                                               // 7\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"shell-server.js\":[\"babel-runtime/helpers/classCallCheck\",\"babel-runtime/helpers/typeof\",\"assert\",\"path\",\"stream\",\"fs\",\"net\",\"tty\",\"vm\",\"underscore\",\"repl\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/shell-server/shell-server.js                                                                        //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\nmodule.export({listen:function(){return listen},disable:function(){return disable}});var _classCallCheck;module.import(\"babel-runtime/helpers/classCallCheck\",{\"default\":function(v){_classCallCheck=v}});var _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});\n                                                                                                                //\nvar assert = require(\"assert\");                                                                                 // 1\nvar path = require(\"path\");                                                                                     // 2\nvar stream = require(\"stream\");                                                                                 // 3\nvar fs = require(\"fs\");                                                                                         // 4\nvar net = require(\"net\");                                                                                       // 5\nvar tty = require(\"tty\");                                                                                       // 6\nvar vm = require(\"vm\");                                                                                         // 7\nvar _ = require(\"underscore\");                                                                                  // 8\nvar INFO_FILE_MODE = parseInt(\"600\", 8); // Only the owner can read or write.                                   // 9\nvar EXITING_MESSAGE = \"Shell exiting...\";                                                                       // 10\n                                                                                                                //\n// Invoked by the server process to listen for incoming connections from                                        //\n// shell clients. Each connection gets its own REPL instance.                                                   //\nfunction listen(shellDir) {                                                                                     // 14\n  function callback() {                                                                                         // 15\n    new Server(shellDir).listen();                                                                              // 16\n  }                                                                                                             // 17\n                                                                                                                //\n  // If the server is still in the very early stages of starting up,                                            //\n  // Meteor.startup may not available yet.                                                                      //\n  if ((typeof Meteor === \"undefined\" ? \"undefined\" : _typeof(Meteor)) === \"object\") {                           // 21\n    Meteor.startup(callback);                                                                                   // 22\n  } else if ((typeof __meteor_bootstrap__ === \"undefined\" ? \"undefined\" : _typeof(__meteor_bootstrap__)) === \"object\") {\n    var hooks = __meteor_bootstrap__.startupHooks;                                                              // 24\n    if (hooks) {                                                                                                // 25\n      hooks.push(callback);                                                                                     // 26\n    } else {                                                                                                    // 27\n      // As a fallback, just call the callback asynchronously.                                                  //\n      setImmediate(callback);                                                                                   // 29\n    }                                                                                                           // 30\n  }                                                                                                             // 31\n}                                                                                                               // 32\n                                                                                                                //\n// Disabling the shell causes all attached clients to disconnect and exit.                                      //\nfunction disable(shellDir) {                                                                                    // 35\n  try {                                                                                                         // 36\n    // Replace info.json with a file that says the shell server is                                              //\n    // disabled, so that any connected shell clients will fail to                                               //\n    // reconnect after the server process closes their sockets.                                                 //\n    fs.writeFileSync(getInfoFile(shellDir), JSON.stringify({                                                    // 40\n      status: \"disabled\",                                                                                       // 43\n      reason: \"Shell server has shut down.\"                                                                     // 44\n    }) + \"\\n\", { mode: INFO_FILE_MODE });                                                                       // 42\n  } catch (ignored) {}                                                                                          // 48\n}                                                                                                               // 49\n                                                                                                                //\nvar Server = function () {                                                                                      //\n  function Server(shellDir) {                                                                                   // 52\n    _classCallCheck(this, Server);                                                                              // 52\n                                                                                                                //\n    var self = this;                                                                                            // 53\n    assert.ok(self instanceof Server);                                                                          // 54\n                                                                                                                //\n    self.shellDir = shellDir;                                                                                   // 56\n    self.key = Math.random().toString(36).slice(2);                                                             // 57\n                                                                                                                //\n    self.server = net.createServer(function (socket) {                                                          // 59\n      self.onConnection(socket);                                                                                // 60\n    }).on(\"error\", function (err) {                                                                             // 61\n      console.error(err.stack);                                                                                 // 62\n    });                                                                                                         // 63\n  }                                                                                                             // 64\n                                                                                                                //\n  Server.prototype.listen = function listen() {                                                                 //\n    var self = this;                                                                                            // 67\n    var infoFile = getInfoFile(self.shellDir);                                                                  // 68\n                                                                                                                //\n    fs.unlink(infoFile, function () {                                                                           // 70\n      self.server.listen(0, \"127.0.0.1\", function () {                                                          // 71\n        fs.writeFileSync(infoFile, JSON.stringify({                                                             // 72\n          status: \"enabled\",                                                                                    // 73\n          port: self.server.address().port,                                                                     // 74\n          key: self.key                                                                                         // 75\n        }) + \"\\n\", {                                                                                            // 72\n          mode: INFO_FILE_MODE                                                                                  // 77\n        });                                                                                                     // 76\n      });                                                                                                       // 79\n    });                                                                                                         // 80\n  };                                                                                                            // 81\n                                                                                                                //\n  Server.prototype.onConnection = function onConnection(socket) {                                               //\n    var self = this;                                                                                            // 84\n                                                                                                                //\n    // Make sure this function doesn't try to write anything to the socket                                      //\n    // after it has been closed.                                                                                //\n    socket.on(\"close\", function () {                                                                            // 88\n      socket = null;                                                                                            // 89\n    });                                                                                                         // 90\n                                                                                                                //\n    // If communication is not established within 1000ms of the first                                           //\n    // connection, forcibly close the socket.                                                                   //\n    var timeout = setTimeout(function () {                                                                      // 94\n      if (socket) {                                                                                             // 95\n        socket.removeAllListeners(\"data\");                                                                      // 96\n        socket.end(EXITING_MESSAGE + \"\\n\");                                                                     // 97\n      }                                                                                                         // 98\n    }, 1000);                                                                                                   // 99\n                                                                                                                //\n    // Let connecting clients configure certain REPL options by sending a                                       //\n    // JSON object over the socket. For example, only the client knows                                          //\n    // whether it's running a TTY or an Emacs subshell or some other kind of                                    //\n    // terminal, so the client must decide the value of options.terminal.                                       //\n    readJSONFromStream(socket, function (error, options, replInputSocket) {                                     // 105\n      clearTimeout(timeout);                                                                                    // 106\n                                                                                                                //\n      if (error) {                                                                                              // 108\n        socket = null;                                                                                          // 109\n        console.error(error.stack);                                                                             // 110\n        return;                                                                                                 // 111\n      }                                                                                                         // 112\n                                                                                                                //\n      if (options.key !== self.key) {                                                                           // 114\n        if (socket) {                                                                                           // 115\n          socket.end(EXITING_MESSAGE + \"\\n\");                                                                   // 116\n        }                                                                                                       // 117\n        return;                                                                                                 // 118\n      }                                                                                                         // 119\n      delete options.key;                                                                                       // 120\n                                                                                                                //\n      if (options.evaluateAndExit) {                                                                            // 122\n        evalCommand.call(Object.create(null), // Dummy repl object without ._RecoverableError.                  // 123\n        \"(\" + options.evaluateAndExit.command + \")\", null, // evalCommand ignores the context parameter, anyway\n        options.evaluateAndExit.filename || \"<meteor shell>\", function (error, result) {                        // 127\n          if (socket) {                                                                                         // 129\n            var message = error ? {                                                                             // 130\n              error: error + \"\",                                                                                // 131\n              code: 1                                                                                           // 132\n            } : {                                                                                               // 130\n              result: result                                                                                    // 134\n            };                                                                                                  // 133\n                                                                                                                //\n            // Sending back a JSON payload allows the client to                                                 //\n            // distinguish between errors and successful results.                                               //\n            socket.end(JSON.stringify(message) + \"\\n\");                                                         // 139\n          }                                                                                                     // 140\n        });                                                                                                     // 141\n        return;                                                                                                 // 143\n      }                                                                                                         // 144\n      delete options.evaluateAndExit;                                                                           // 145\n                                                                                                                //\n      // Immutable options.                                                                                     //\n      _.extend(options, {                                                                                       // 148\n        input: replInputSocket,                                                                                 // 149\n        output: socket                                                                                          // 150\n      });                                                                                                       // 148\n                                                                                                                //\n      // Overridable options.                                                                                   //\n      _.defaults(options, {                                                                                     // 154\n        prompt: \"> \",                                                                                           // 155\n        terminal: true,                                                                                         // 156\n        useColors: true,                                                                                        // 157\n        useGlobal: true,                                                                                        // 158\n        ignoreUndefined: true                                                                                   // 159\n      });                                                                                                       // 154\n                                                                                                                //\n      self.startREPL(options);                                                                                  // 162\n    });                                                                                                         // 163\n  };                                                                                                            // 164\n                                                                                                                //\n  Server.prototype.startREPL = function startREPL(options) {                                                    //\n    var self = this;                                                                                            // 167\n                                                                                                                //\n    if (!options.output.columns) {                                                                              // 169\n      // The REPL's tab completion logic assumes process.stdout is a TTY,                                       //\n      // and while that isn't technically true here, we can get tab                                             //\n      // completion to behave correctly if we fake the .columns property.                                       //\n      options.output.columns = getTerminalWidth();                                                              // 173\n    }                                                                                                           // 174\n                                                                                                                //\n    // Make sure this function doesn't try to write anything to the output                                      //\n    // stream after it has been closed.                                                                         //\n    options.output.on(\"close\", function () {                                                                    // 178\n      options.output = null;                                                                                    // 179\n    });                                                                                                         // 180\n                                                                                                                //\n    var repl = self.repl = require(\"repl\").start(options);                                                      // 182\n                                                                                                                //\n    // History persists across shell sessions!                                                                  //\n    self.initializeHistory();                                                                                   // 185\n                                                                                                                //\n    // Save the global `_` object in the server.  This is probably defined by the                               //\n    // underscore package.  It is unlikely to be the same object as the `var _ =                                //\n    // require('underscore')` in this file!                                                                     //\n    var originalUnderscore = repl.context._;                                                                    // 190\n                                                                                                                //\n    Object.defineProperty(repl.context, \"_\", {                                                                  // 192\n      // Force the global _ variable to remain bound to underscore.                                             //\n      get: function get() {                                                                                     // 194\n        return originalUnderscore;                                                                              // 194\n      },                                                                                                        // 194\n                                                                                                                //\n      // Expose the last REPL result as __ instead of _.                                                        //\n      set: function set(lastResult) {                                                                           // 197\n        repl.context.__ = lastResult;                                                                           // 198\n      },                                                                                                        // 199\n                                                                                                                //\n      enumerable: true,                                                                                         // 201\n                                                                                                                //\n      // Allow this property to be (re)defined more than once (e.g. each                                        //\n      // time the server restarts).                                                                             //\n      configurable: true                                                                                        // 205\n    });                                                                                                         // 192\n                                                                                                                //\n    if (Package.modules) {                                                                                      // 208\n      // Use the same `require` function and `module` object visible to the                                     //\n      // application.                                                                                           //\n      var toBeInstalled = {};                                                                                   // 211\n      var shellModuleName = \"meteor-shell-\" + Math.random().toString(36).slice(2) + \".js\";                      // 212\n                                                                                                                //\n      toBeInstalled[shellModuleName] = function (require, exports, module) {                                    // 215\n        repl.context.module = module;                                                                           // 216\n        repl.context.require = require;                                                                         // 217\n                                                                                                                //\n        // Tab completion sometimes uses require.extensions, but only for                                       //\n        // the keys.                                                                                            //\n        require.extensions = {                                                                                  // 221\n          \".js\": true,                                                                                          // 222\n          \".json\": true,                                                                                        // 223\n          \".node\": true                                                                                         // 224\n        };                                                                                                      // 221\n      };                                                                                                        // 226\n                                                                                                                //\n      // This populates repl.context.{module,require} by evaluating the                                         //\n      // module defined above.                                                                                  //\n      Package.modules.meteorInstall(toBeInstalled)(\"./\" + shellModuleName);                                     // 230\n    }                                                                                                           // 231\n                                                                                                                //\n    repl.context.repl = repl;                                                                                   // 233\n                                                                                                                //\n    // Some improvements to the existing help messages.                                                         //\n    function addHelp(cmd, helpText) {                                                                           // 236\n      var info = repl.commands[cmd] || repl.commands[\".\" + cmd];                                                // 237\n      if (info) {                                                                                               // 238\n        info.help = helpText;                                                                                   // 239\n      }                                                                                                         // 240\n    }                                                                                                           // 241\n    addHelp(\"break\", \"Terminate current command input and display new prompt\");                                 // 242\n    addHelp(\"exit\", \"Disconnect from server and leave shell\");                                                  // 243\n    addHelp(\"help\", \"Show this help information\");                                                              // 244\n                                                                                                                //\n    // When the REPL exits, signal the attached client to exit by sending it                                    //\n    // the special EXITING_MESSAGE.                                                                             //\n    repl.on(\"exit\", function () {                                                                               // 248\n      if (options.output) {                                                                                     // 249\n        options.output.write(EXITING_MESSAGE + \"\\n\");                                                           // 250\n        options.output.end();                                                                                   // 251\n      }                                                                                                         // 252\n    });                                                                                                         // 253\n                                                                                                                //\n    // When the server process exits, end the output stream but do not                                          //\n    // signal the attached client to exit.                                                                      //\n    process.on(\"exit\", function () {                                                                            // 257\n      if (options.output) {                                                                                     // 258\n        options.output.end();                                                                                   // 259\n      }                                                                                                         // 260\n    });                                                                                                         // 261\n                                                                                                                //\n    // This Meteor-specific shell command rebuilds the application as if a                                      //\n    // change was made to server code.                                                                          //\n    repl.defineCommand(\"reload\", {                                                                              // 265\n      help: \"Restart the server and the shell\",                                                                 // 266\n      action: function action() {                                                                               // 267\n        process.exit(0);                                                                                        // 268\n      }                                                                                                         // 269\n    });                                                                                                         // 265\n                                                                                                                //\n    // Trigger one recoverable error using the default eval function, just                                      //\n    // to capture the Recoverable error constructor, so that our custom                                         //\n    // evalCommand function can wrap recoverable errors properly.                                               //\n    repl.eval(\"{\", null, \"<meteor shell>\", function (error) {                                                   // 275\n      // Capture the Recoverable error constructor.                                                             //\n      repl._RecoverableError = error && error.constructor;                                                      // 279\n                                                                                                                //\n      // Now set repl.eval to the actual evalCommand function that we want                                      //\n      // to use, bound to repl._domain if necessary.                                                            //\n      repl.eval = repl._domain ? repl._domain.bind(evalCommand) : evalCommand;                                  // 283\n                                                                                                                //\n      // Terminate the partial evaluation of the { command.                                                     //\n      repl.commands[\"break\"].action.call(repl);                                                                 // 288\n    });                                                                                                         // 289\n  };                                                                                                            // 291\n                                                                                                                //\n  // This function allows a persistent history of shell commands to be saved                                    //\n  // to and loaded from .meteor/local/shell-history.                                                            //\n                                                                                                                //\n                                                                                                                //\n  Server.prototype.initializeHistory = function initializeHistory() {                                           //\n    var self = this;                                                                                            // 296\n    var rli = self.repl.rli;                                                                                    // 297\n    var historyFile = getHistoryFile(self.shellDir);                                                            // 298\n    var historyFd = fs.openSync(historyFile, \"a+\");                                                             // 299\n    var historyLines = fs.readFileSync(historyFile, \"utf8\").split(\"\\n\");                                        // 300\n    var seenLines = Object.create(null);                                                                        // 301\n                                                                                                                //\n    if (!rli.history) {                                                                                         // 303\n      rli.history = [];                                                                                         // 304\n      rli.historyIndex = -1;                                                                                    // 305\n    }                                                                                                           // 306\n                                                                                                                //\n    while (rli.history && historyLines.length > 0) {                                                            // 308\n      var line = historyLines.pop();                                                                            // 309\n      if (line && /\\S/.test(line) && !seenLines[line]) {                                                        // 310\n        rli.history.push(line);                                                                                 // 311\n        seenLines[line] = true;                                                                                 // 312\n      }                                                                                                         // 313\n    }                                                                                                           // 314\n                                                                                                                //\n    rli.addListener(\"line\", function (line) {                                                                   // 316\n      if (historyFd >= 0 && /\\S/.test(line)) {                                                                  // 317\n        fs.writeSync(historyFd, line + \"\\n\");                                                                   // 318\n      }                                                                                                         // 319\n    });                                                                                                         // 320\n                                                                                                                //\n    self.repl.on(\"exit\", function () {                                                                          // 322\n      fs.closeSync(historyFd);                                                                                  // 323\n      historyFd = -1;                                                                                           // 324\n    });                                                                                                         // 325\n  };                                                                                                            // 326\n                                                                                                                //\n  return Server;                                                                                                //\n}();                                                                                                            //\n                                                                                                                //\nfunction readJSONFromStream(inputStream, callback) {                                                            // 329\n  var outputStream = new stream.PassThrough();                                                                  // 330\n  var dataSoFar = \"\";                                                                                           // 331\n                                                                                                                //\n  function onData(buffer) {                                                                                     // 333\n    var lines = buffer.toString(\"utf8\").split(\"\\n\");                                                            // 334\n                                                                                                                //\n    while (lines.length > 0) {                                                                                  // 336\n      dataSoFar += lines.shift();                                                                               // 337\n                                                                                                                //\n      try {                                                                                                     // 339\n        var json = JSON.parse(dataSoFar);                                                                       // 340\n      } catch (error) {                                                                                         // 341\n        if (error instanceof SyntaxError) {                                                                     // 342\n          continue;                                                                                             // 343\n        }                                                                                                       // 344\n                                                                                                                //\n        return finish(error);                                                                                   // 346\n      }                                                                                                         // 347\n                                                                                                                //\n      if (lines.length > 0) {                                                                                   // 349\n        outputStream.write(lines.join(\"\\n\"));                                                                   // 350\n      }                                                                                                         // 351\n                                                                                                                //\n      inputStream.pipe(outputStream);                                                                           // 353\n                                                                                                                //\n      return finish(null, json);                                                                                // 355\n    }                                                                                                           // 356\n  }                                                                                                             // 357\n                                                                                                                //\n  function onClose() {                                                                                          // 359\n    finish(new Error(\"stream unexpectedly closed\"));                                                            // 360\n  }                                                                                                             // 361\n                                                                                                                //\n  var finished = false;                                                                                         // 363\n  function finish(error, json) {                                                                                // 364\n    if (!finished) {                                                                                            // 365\n      finished = true;                                                                                          // 366\n      inputStream.removeListener(\"data\", onData);                                                               // 367\n      inputStream.removeListener(\"error\", finish);                                                              // 368\n      inputStream.removeListener(\"close\", onClose);                                                             // 369\n      callback(error, json, outputStream);                                                                      // 370\n    }                                                                                                           // 371\n  }                                                                                                             // 372\n                                                                                                                //\n  inputStream.on(\"data\", onData);                                                                               // 374\n  inputStream.on(\"error\", finish);                                                                              // 375\n  inputStream.on(\"close\", onClose);                                                                             // 376\n}                                                                                                               // 377\n                                                                                                                //\nfunction getInfoFile(shellDir) {                                                                                // 379\n  return path.join(shellDir, \"info.json\");                                                                      // 380\n}                                                                                                               // 381\n                                                                                                                //\nfunction getHistoryFile(shellDir) {                                                                             // 383\n  return path.join(shellDir, \"history\");                                                                        // 384\n}                                                                                                               // 385\n                                                                                                                //\nfunction getTerminalWidth() {                                                                                   // 387\n  try {                                                                                                         // 388\n    // Inspired by https://github.com/TooTallNate/ttys/blob/master/index.js                                     //\n    var fd = fs.openSync(\"/dev/tty\", \"r\");                                                                      // 390\n    assert.ok(tty.isatty(fd));                                                                                  // 391\n    var ws = new tty.WriteStream(fd);                                                                           // 392\n    ws.end();                                                                                                   // 393\n    return ws.columns;                                                                                          // 394\n  } catch (fancyApproachWasTooFancy) {                                                                          // 395\n    return 80;                                                                                                  // 396\n  }                                                                                                             // 397\n}                                                                                                               // 398\n                                                                                                                //\n// Shell commands need to be executed in a Fiber in case they call into                                         //\n// code that yields. Using a Promise is an even better idea, since it runs                                      //\n// its callbacks in Fibers drawn from a pool, so the Fibers are recycled.                                       //\nvar evalCommandPromise = Promise.resolve();                                                                     // 403\n                                                                                                                //\nfunction evalCommand(command, context, filename, callback) {                                                    // 405\n  var repl = this;                                                                                              // 406\n                                                                                                                //\n  function finish(error, result) {                                                                              // 408\n    if (error) {                                                                                                // 409\n      if (repl._RecoverableError && isRecoverableError(error, repl)) {                                          // 410\n        callback(new repl._RecoverableError(error));                                                            // 412\n      } else {                                                                                                  // 413\n        callback(error);                                                                                        // 414\n      }                                                                                                         // 415\n    } else {                                                                                                    // 416\n      callback(null, result);                                                                                   // 417\n    }                                                                                                           // 418\n  }                                                                                                             // 419\n                                                                                                                //\n  if (Package.ecmascript) {                                                                                     // 421\n    var noParens = stripParens(command);                                                                        // 422\n    if (noParens !== command) {                                                                                 // 423\n      var classMatch = /^\\s*class\\s+(\\w+)/.exec(noParens);                                                      // 424\n      if (classMatch && classMatch[1] !== \"extends\") {                                                          // 425\n        // If the command looks like a named ES2015 class, we remove the                                        //\n        // extra layer of parentheses added by the REPL so that the                                             //\n        // command will be evaluated as a class declaration rather than as                                      //\n        // a named class expression. Note that you can still type (class A                                      //\n        // {}) explicitly to evaluate a named class expression. The REPL                                        //\n        // code that calls evalCommand handles named function expressions                                       //\n        // similarly (first with and then without parentheses), but that                                        //\n        // code doesn't know about ES2015 classes, which is why we have to                                      //\n        // handle them here.                                                                                    //\n        command = noParens;                                                                                     // 435\n      }                                                                                                         // 436\n    }                                                                                                           // 437\n                                                                                                                //\n    try {                                                                                                       // 439\n      command = Package.ecmascript.ECMAScript.compileForShell(command);                                         // 440\n    } catch (error) {                                                                                           // 441\n      finish(error);                                                                                            // 442\n      return;                                                                                                   // 443\n    }                                                                                                           // 444\n  }                                                                                                             // 445\n                                                                                                                //\n  try {                                                                                                         // 447\n    var script = new vm.Script(command, {                                                                       // 448\n      filename: filename,                                                                                       // 449\n      displayErrors: false                                                                                      // 450\n    });                                                                                                         // 448\n  } catch (parseError) {                                                                                        // 452\n    finish(parseError);                                                                                         // 453\n    return;                                                                                                     // 454\n  }                                                                                                             // 455\n                                                                                                                //\n  evalCommandPromise.then(function () {                                                                         // 457\n    finish(null, script.runInThisContext());                                                                    // 458\n  })[\"catch\"](finish);                                                                                          // 459\n}                                                                                                               // 460\n                                                                                                                //\nfunction stripParens(command) {                                                                                 // 462\n  if (command.charAt(0) === \"(\" && command.charAt(command.length - 1) === \")\") {                                // 463\n    return command.slice(1, command.length - 1);                                                                // 465\n  }                                                                                                             // 466\n  return command;                                                                                               // 467\n}                                                                                                               // 468\n                                                                                                                //\n// The bailOnIllegalToken and isRecoverableError functions are taken from                                       //\n// https://github.com/nodejs/node/blob/c9e670ea2a/lib/repl.js#L1227-L1253                                       //\nfunction bailOnIllegalToken(parser) {                                                                           // 472\n  return parser._literal === null && !parser.blockComment && !parser.regExpLiteral;                             // 473\n}                                                                                                               // 476\n                                                                                                                //\n// If the error is that we've unexpectedly ended the input,                                                     //\n// then let the user try to recover by adding more input.                                                       //\nfunction isRecoverableError(e, repl) {                                                                          // 480\n  if (e && e.name === 'SyntaxError') {                                                                          // 481\n    var message = e.message;                                                                                    // 482\n    if (message === 'Unterminated template literal' || message === 'Missing } in template expression') {        // 483\n      repl._inTemplateLiteral = true;                                                                           // 485\n      return true;                                                                                              // 486\n    }                                                                                                           // 487\n                                                                                                                //\n    if (message.startsWith('Unexpected end of input') || message.startsWith('missing ) after argument list') || message.startsWith('Unexpected token')) {\n      return true;                                                                                              // 492\n    }                                                                                                           // 493\n                                                                                                                //\n    if (message === 'Invalid or unexpected token') {                                                            // 495\n      return !bailOnIllegalToken(repl.lineParser);                                                              // 496\n    }                                                                                                           // 497\n  }                                                                                                             // 498\n                                                                                                                //\n  return false;                                                                                                 // 500\n}                                                                                                               // 501\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/shell-server/main.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['shell-server'] = exports;\n\n})();\n","servePath":"/packages/shell-server.js","sourceMap":{"version":3,"sources":["/packages/shell-server/main.js","/packages/shell-server/shell-server.js"],"names":[],"mappings":"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","file":"/packages/shell-server.js","sourcesContent":["export * from \"./shell-server.js\";\nimport { listen } from \"./shell-server.js\";\n\nconst shellDir = process.env.METEOR_SHELL_DIR;\nif (shellDir) {\n  listen(shellDir);\n}\n","var assert = require(\"assert\");\nvar path = require(\"path\");\nvar stream = require(\"stream\");\nvar fs = require(\"fs\");\nvar net = require(\"net\");\nvar tty = require(\"tty\");\nvar vm = require(\"vm\");\nvar _ = require(\"underscore\");\nvar INFO_FILE_MODE = parseInt(\"600\", 8); // Only the owner can read or write.\nvar EXITING_MESSAGE = \"Shell exiting...\";\n\n// Invoked by the server process to listen for incoming connections from\n// shell clients. Each connection gets its own REPL instance.\nexport function listen(shellDir) {\n  function callback() {\n    new Server(shellDir).listen();\n  }\n\n  // If the server is still in the very early stages of starting up,\n  // Meteor.startup may not available yet.\n  if (typeof Meteor === \"object\") {\n    Meteor.startup(callback);\n  } else if (typeof __meteor_bootstrap__ === \"object\") {\n    var hooks = __meteor_bootstrap__.startupHooks;\n    if (hooks) {\n      hooks.push(callback);\n    } else {\n      // As a fallback, just call the callback asynchronously.\n      setImmediate(callback);\n    }\n  }\n}\n\n// Disabling the shell causes all attached clients to disconnect and exit.\nexport function disable(shellDir) {\n  try {\n    // Replace info.json with a file that says the shell server is\n    // disabled, so that any connected shell clients will fail to\n    // reconnect after the server process closes their sockets.\n    fs.writeFileSync(\n      getInfoFile(shellDir),\n      JSON.stringify({\n        status: \"disabled\",\n        reason: \"Shell server has shut down.\"\n      }) + \"\\n\",\n      { mode: INFO_FILE_MODE }\n    );\n  } catch (ignored) {}\n}\n\nclass Server {\n  constructor(shellDir) {\n    var self = this;\n    assert.ok(self instanceof Server);\n\n    self.shellDir = shellDir;\n    self.key = Math.random().toString(36).slice(2);\n\n    self.server = net.createServer(function(socket) {\n      self.onConnection(socket);\n    }).on(\"error\", function(err) {\n      console.error(err.stack);\n    });\n  }\n\n  listen() {\n    var self = this;\n    var infoFile = getInfoFile(self.shellDir);\n\n    fs.unlink(infoFile, function() {\n      self.server.listen(0, \"127.0.0.1\", function() {\n        fs.writeFileSync(infoFile, JSON.stringify({\n          status: \"enabled\",\n          port: self.server.address().port,\n          key: self.key\n        }) + \"\\n\", {\n          mode: INFO_FILE_MODE\n        });\n      });\n    });\n  }\n\n  onConnection(socket) {\n    var self = this;\n\n    // Make sure this function doesn't try to write anything to the socket\n    // after it has been closed.\n    socket.on(\"close\", function() {\n      socket = null;\n    });\n\n    // If communication is not established within 1000ms of the first\n    // connection, forcibly close the socket.\n    var timeout = setTimeout(function() {\n      if (socket) {\n        socket.removeAllListeners(\"data\");\n        socket.end(EXITING_MESSAGE + \"\\n\");\n      }\n    }, 1000);\n\n    // Let connecting clients configure certain REPL options by sending a\n    // JSON object over the socket. For example, only the client knows\n    // whether it's running a TTY or an Emacs subshell or some other kind of\n    // terminal, so the client must decide the value of options.terminal.\n    readJSONFromStream(socket, function (error, options, replInputSocket) {\n      clearTimeout(timeout);\n\n      if (error) {\n        socket = null;\n        console.error(error.stack);\n        return;\n      }\n\n      if (options.key !== self.key) {\n        if (socket) {\n          socket.end(EXITING_MESSAGE + \"\\n\");\n        }\n        return;\n      }\n      delete options.key;\n\n      if (options.evaluateAndExit) {\n        evalCommand.call(\n          Object.create(null), // Dummy repl object without ._RecoverableError.\n          \"(\" + options.evaluateAndExit.command + \")\",\n          null, // evalCommand ignores the context parameter, anyway\n          options.evaluateAndExit.filename || \"<meteor shell>\",\n          function (error, result) {\n            if (socket) {\n              var message = error ? {\n                error: error + \"\",\n                code: 1\n              } : {\n                result: result\n              };\n\n              // Sending back a JSON payload allows the client to\n              // distinguish between errors and successful results.\n              socket.end(JSON.stringify(message) + \"\\n\");\n            }\n          }\n        );\n        return;\n      }\n      delete options.evaluateAndExit;\n\n      // Immutable options.\n      _.extend(options, {\n        input: replInputSocket,\n        output: socket\n      });\n\n      // Overridable options.\n      _.defaults(options, {\n        prompt: \"> \",\n        terminal: true,\n        useColors: true,\n        useGlobal: true,\n        ignoreUndefined: true,\n      });\n\n      self.startREPL(options);\n    });\n  }\n\n  startREPL(options) {\n    var self = this;\n\n    if (! options.output.columns) {\n      // The REPL's tab completion logic assumes process.stdout is a TTY,\n      // and while that isn't technically true here, we can get tab\n      // completion to behave correctly if we fake the .columns property.\n      options.output.columns = getTerminalWidth();\n    }\n\n    // Make sure this function doesn't try to write anything to the output\n    // stream after it has been closed.\n    options.output.on(\"close\", function() {\n      options.output = null;\n    });\n\n    var repl = self.repl = require(\"repl\").start(options);\n\n    // History persists across shell sessions!\n    self.initializeHistory();\n\n    // Save the global `_` object in the server.  This is probably defined by the\n    // underscore package.  It is unlikely to be the same object as the `var _ =\n    // require('underscore')` in this file!\n    var originalUnderscore = repl.context._;\n\n    Object.defineProperty(repl.context, \"_\", {\n      // Force the global _ variable to remain bound to underscore.\n      get: function () { return originalUnderscore; },\n\n      // Expose the last REPL result as __ instead of _.\n      set: function(lastResult) {\n        repl.context.__ = lastResult;\n      },\n\n      enumerable: true,\n\n      // Allow this property to be (re)defined more than once (e.g. each\n      // time the server restarts).\n      configurable: true\n    });\n\n    if (Package.modules) {\n      // Use the same `require` function and `module` object visible to the\n      // application.\n      var toBeInstalled = {};\n      var shellModuleName = \"meteor-shell-\" +\n        Math.random().toString(36).slice(2) + \".js\";\n\n      toBeInstalled[shellModuleName] = function (require, exports, module) {\n        repl.context.module = module;\n        repl.context.require = require;\n\n        // Tab completion sometimes uses require.extensions, but only for\n        // the keys.\n        require.extensions = {\n          \".js\": true,\n          \".json\": true,\n          \".node\": true,\n        };\n      };\n\n      // This populates repl.context.{module,require} by evaluating the\n      // module defined above.\n      Package.modules.meteorInstall(toBeInstalled)(\"./\" + shellModuleName);\n    }\n\n    repl.context.repl = repl;\n\n    // Some improvements to the existing help messages.\n    function addHelp(cmd, helpText) {\n      var info = repl.commands[cmd] || repl.commands[\".\" + cmd];\n      if (info) {\n        info.help = helpText;\n      }\n    }\n    addHelp(\"break\", \"Terminate current command input and display new prompt\");\n    addHelp(\"exit\", \"Disconnect from server and leave shell\");\n    addHelp(\"help\", \"Show this help information\");\n\n    // When the REPL exits, signal the attached client to exit by sending it\n    // the special EXITING_MESSAGE.\n    repl.on(\"exit\", function() {\n      if (options.output) {\n        options.output.write(EXITING_MESSAGE + \"\\n\");\n        options.output.end();\n      }\n    });\n\n    // When the server process exits, end the output stream but do not\n    // signal the attached client to exit.\n    process.on(\"exit\", function() {\n      if (options.output) {\n        options.output.end();\n      }\n    });\n\n    // This Meteor-specific shell command rebuilds the application as if a\n    // change was made to server code.\n    repl.defineCommand(\"reload\", {\n      help: \"Restart the server and the shell\",\n      action: function() {\n        process.exit(0);\n      }\n    });\n\n    // Trigger one recoverable error using the default eval function, just\n    // to capture the Recoverable error constructor, so that our custom\n    // evalCommand function can wrap recoverable errors properly.\n    repl.eval(\n      \"{\", null, \"<meteor shell>\",\n      function (error) {\n        // Capture the Recoverable error constructor.\n        repl._RecoverableError = error && error.constructor;\n\n        // Now set repl.eval to the actual evalCommand function that we want\n        // to use, bound to repl._domain if necessary.\n        repl.eval = repl._domain\n          ? repl._domain.bind(evalCommand)\n          : evalCommand;\n\n        // Terminate the partial evaluation of the { command.\n        repl.commands[\"break\"].action.call(repl);\n      }\n    );\n  }\n\n  // This function allows a persistent history of shell commands to be saved\n  // to and loaded from .meteor/local/shell-history.\n  initializeHistory() {\n    var self = this;\n    var rli = self.repl.rli;\n    var historyFile = getHistoryFile(self.shellDir);\n    var historyFd = fs.openSync(historyFile, \"a+\");\n    var historyLines = fs.readFileSync(historyFile, \"utf8\").split(\"\\n\");\n    var seenLines = Object.create(null);\n\n    if (! rli.history) {\n      rli.history = [];\n      rli.historyIndex = -1;\n    }\n\n    while (rli.history && historyLines.length > 0) {\n      var line = historyLines.pop();\n      if (line && /\\S/.test(line) && ! seenLines[line]) {\n        rli.history.push(line);\n        seenLines[line] = true;\n      }\n    }\n\n    rli.addListener(\"line\", function(line) {\n      if (historyFd >= 0 && /\\S/.test(line)) {\n        fs.writeSync(historyFd, line + \"\\n\");\n      }\n    });\n\n    self.repl.on(\"exit\", function() {\n      fs.closeSync(historyFd);\n      historyFd = -1;\n    });\n  }\n}\n\nfunction readJSONFromStream(inputStream, callback) {\n  var outputStream = new stream.PassThrough;\n  var dataSoFar = \"\";\n\n  function onData(buffer) {\n    var lines = buffer.toString(\"utf8\").split(\"\\n\");\n\n    while (lines.length > 0) {\n      dataSoFar += lines.shift();\n\n      try {\n        var json = JSON.parse(dataSoFar);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          continue;\n        }\n\n        return finish(error);\n      }\n\n      if (lines.length > 0) {\n        outputStream.write(lines.join(\"\\n\"));\n      }\n\n      inputStream.pipe(outputStream);\n\n      return finish(null, json);\n    }\n  }\n\n  function onClose() {\n    finish(new Error(\"stream unexpectedly closed\"));\n  }\n\n  var finished = false;\n  function finish(error, json) {\n    if (! finished) {\n      finished = true;\n      inputStream.removeListener(\"data\", onData);\n      inputStream.removeListener(\"error\", finish);\n      inputStream.removeListener(\"close\", onClose);\n      callback(error, json, outputStream);\n    }\n  }\n\n  inputStream.on(\"data\", onData);\n  inputStream.on(\"error\", finish);\n  inputStream.on(\"close\", onClose);\n}\n\nfunction getInfoFile(shellDir) {\n  return path.join(shellDir, \"info.json\");\n}\n\nfunction getHistoryFile(shellDir) {\n  return path.join(shellDir, \"history\");\n}\n\nfunction getTerminalWidth() {\n  try {\n    // Inspired by https://github.com/TooTallNate/ttys/blob/master/index.js\n    var fd = fs.openSync(\"/dev/tty\", \"r\");\n    assert.ok(tty.isatty(fd));\n    var ws = new tty.WriteStream(fd);\n    ws.end();\n    return ws.columns;\n  } catch (fancyApproachWasTooFancy) {\n    return 80;\n  }\n}\n\n// Shell commands need to be executed in a Fiber in case they call into\n// code that yields. Using a Promise is an even better idea, since it runs\n// its callbacks in Fibers drawn from a pool, so the Fibers are recycled.\nvar evalCommandPromise = Promise.resolve();\n\nfunction evalCommand(command, context, filename, callback) {\n  var repl = this;\n\n  function finish(error, result) {\n    if (error) {\n      if (repl._RecoverableError &&\n          isRecoverableError(error, repl)) {\n        callback(new repl._RecoverableError(error));\n      } else {\n        callback(error);\n      }\n    } else {\n      callback(null, result);\n    }\n  }\n\n  if (Package.ecmascript) {\n    var noParens = stripParens(command);\n    if (noParens !== command) {\n      var classMatch = /^\\s*class\\s+(\\w+)/.exec(noParens);\n      if (classMatch && classMatch[1] !== \"extends\") {\n        // If the command looks like a named ES2015 class, we remove the\n        // extra layer of parentheses added by the REPL so that the\n        // command will be evaluated as a class declaration rather than as\n        // a named class expression. Note that you can still type (class A\n        // {}) explicitly to evaluate a named class expression. The REPL\n        // code that calls evalCommand handles named function expressions\n        // similarly (first with and then without parentheses), but that\n        // code doesn't know about ES2015 classes, which is why we have to\n        // handle them here.\n        command = noParens;\n      }\n    }\n\n    try {\n      command = Package.ecmascript.ECMAScript.compileForShell(command);\n    } catch (error) {\n      finish(error);\n      return;\n    }\n  }\n\n  try {\n    var script = new vm.Script(command, {\n      filename: filename,\n      displayErrors: false\n    });\n  } catch (parseError) {\n    finish(parseError);\n    return;\n  }\n\n  evalCommandPromise.then(function () {\n    finish(null, script.runInThisContext());\n  }).catch(finish);\n}\n\nfunction stripParens(command) {\n  if (command.charAt(0) === \"(\" &&\n      command.charAt(command.length - 1) === \")\") {\n    return command.slice(1, command.length - 1);\n  }\n  return command;\n}\n\n// The bailOnIllegalToken and isRecoverableError functions are taken from\n// https://github.com/nodejs/node/blob/c9e670ea2a/lib/repl.js#L1227-L1253\nfunction bailOnIllegalToken(parser) {\n  return parser._literal === null &&\n    ! parser.blockComment &&\n    ! parser.regExpLiteral;\n}\n\n// If the error is that we've unexpectedly ended the input,\n// then let the user try to recover by adding more input.\nfunction isRecoverableError(e, repl) {\n  if (e && e.name === 'SyntaxError') {\n    var message = e.message;\n    if (message === 'Unterminated template literal' ||\n        message === 'Missing } in template expression') {\n      repl._inTemplateLiteral = true;\n      return true;\n    }\n\n    if (message.startsWith('Unexpected end of input') ||\n        message.startsWith('missing ) after argument list') ||\n        message.startsWith('Unexpected token')) {\n      return true;\n    }\n\n    if (message === 'Invalid or unexpected token') {\n      return ! bailOnIllegalToken(repl.lineParser);\n    }\n  }\n\n  return false;\n}\n"]}}]